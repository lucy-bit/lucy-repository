#define _CRT_SECURE_NO_WARNINGS 1
//字符串拷贝函数
//char * my_strcpy(char *dest, const char *src)
//{
//	char * ret = dest;
//	assert（dest != NULL）；
//		assert（src != NULL）；
//	while (*dest++ = *src++)
//	{
//		；
//	}
//	return ret;
//}
//1. const如果放在*的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。但是指针变量本身的内容可变。
//2. const如果放在*的右边，修饰的是指针变量本身，保证了指针变量的内容不能修改，但是指针指向的内容，可以通过指针改变
//
//字符串追加函数
//char * my_strcat(char * dest, const char * src)
//{
//	char *ret = dest;
//	assert(dest && src);
//	while (*dest)
//	{
//		dest++;
//	}
//	while (*dest++ = *src++)
//	{
//		;
//	}
//	return ret;
//}
//
//字符串比较函数
//int my_strcmp(char * str1, char *str2)
//{
//	while (*str1 == *str2)
//	{
//		if (*str1 == '\0')
//			return 0;
//		str1++;
//		str2++;
//	}
//	return *str1 - *str2;
//}
//
//
//int my_strlen(const char * str)//指针减指针 递归 计数器
//{
//	int const = 0;
//	assert(str != NULL);
//	while (*str++)
//	{
//		const++;
//	}
//	return const;
//}
//
//
//%s格式码及其他格式码（除了%c）输入字符串时，中间不能包含空白 空白后的会被跳过
//有的编译器如果if和while后边的条件内有赋值语句，会报警告，但经测试，vs不会报警告
//
//
//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位, ，保存在内存的高地址中。
//设计一个小程序来判断当前机器的字节序：
//int Judge_char(int i)
//{
//	return *(char *)&i;
//}
//int main()
//{
//	int i = 1;
//	int ret = Judge_char(i);
//	if (1 == ret)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}
//
////利用联合体来判断大小端
//int mian()
//{
//	union
//	{
//		char c;
//		int i;
//	}u;
//	u.i = 1;
//	if (1 == u.c)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}
//
//
//
//
//
//
//a^a = 0;
//0 ^ a = a;
//
//函数名为函数地址
//
//冒泡排序只能排整数
//
//a^b
//返回型参数：
//
//'\0' ――0
//'0'  ――48
//NULL――0
//EOF - end of file――（ - 1）
//
//KMP算法（实现strstr函数的优化算法）
//
//一个汉字是两个字符
//
//结构体名字为地址
//结构体里面不能初始化
//函数（结构体）传地址效率更高
//
//\续行符
//eg：  pcon\(后边不能有空格）
//->sz
//
//++的优先级要高于()
//
//结构体的对齐规则：
//1.第一个结构体成员放在与结构体变量偏移量为0的地址处
//2.其他的成员变量要对齐到该变量对齐数的整数倍的地址处
//3.结构体的总大小为该结构体成员的最大对齐数的整数倍
//4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所 有最大对齐数（含嵌套结构体的对齐数）的整数倍。
//
//
//
//pragma用来改变结构体的对齐数，应用如下：
//#pragma pack(2)
//struct A
//{
//	char a;
//	int b;
//	char c;
//};
//#pragma pack()
//
//位段是拿时间来换取空间；结构体对齐是拿空间来换取时间
//
//常量：字面常量；const修饰的常变量；define定义的标识符常量；枚举常量
//
//文件信息区是一个结构体变量 : FILE
//
//			stream : 流（用户将信息输入到流里（会有不同的方式，键盘）由流依据底层函数和底层设备完成底层信息的转换）
//
//					 任何一个文件打开后都会打开stdin stdout stderr 三个流
//
//					 一个工程中有且只有一个main函数
//
//					 全局变量作用域时整个工程，局部变量作用域为所在代码块
//
//					 const修饰的变量具有常属性，不可被改变但是还属于变量类型
//
//					 ? ? )――三字母词
//
//					 一种注释的方法：  #if 0
//					 代码
//#endif
//					 这种方法是可以将代码从程序中去除，即使其中原本就含有注释也无妨
//
//					 头文件在引用时，如果是用<>――从标准库目录搜索
//					 如果是“”  ――从用户的工作目录搜索
//
//					 头文件的作用：
//					 1.通过头文件来调用库功能。因为很多场合下是不便于像用户公布源代码的，只要向用户提供头文件和二进制库，用户按照头文件的接口声明来调用库函数，而不用关心接口时怎么实现的
//					 2.头文件能够加强类型的安全检查
//
//					 linux的优点：（在服务器端经常被使用的操作系统）
//					 1.开源操作系统
//					 3.在企业端应用广泛，现在在移动客户端也在应用
//
//					 操作系统是一款搞管理的软件，。对下管理好所有的软硬件资源；对上要为用户提供良好运维环境
//
//					 cd ls加起来相当于双击
//					 pwd显示路径
//					 ls 显示当前目录
//					 cd进入指定目录
//					 mkdir建立目录
//					 touch在当前目录下创建一个文件, 还可以更改一个文件的时间
//					 tree查看树形结构
//
//
//					 linux下的目录分隔符为 / （斜杠）
//					 window下的是\（反斜杠）
//
//					 / 1.根目录
//					 2.目录分隔符
//					 目录结构是树状的（便于确定文件的唯一性）
//
//					 文件由内容和属性构成，一个空文件夹占的内存不是0
//					 文件在硬盘中存放
//
//					 linux下一切皆文件
//					 看 - l下的每行第一个字母是什么：
//					 以d开头表示目录
//					 以 - 开头表示普通文件
//					 p管道文件
//
//					 .当前目录
//					 ..上级目录
//
//					 - l以列表形式显示文件
//					 - a显示隐藏文件
//
//					 相对路径不唯一，相对当前目录而言
//					 绝对路径唯一
//
//					 cd~
//					 cd - 返回最近的目录
//
//					 界面的交控方式
//					 sudo init 5――由黑屏变图标
//					 sudo init 3――由图标换黑屏
//
//					 stat或 ls - l可以显示文件属性
//					 Access进入访问
//					 Context
//					 Modify
//					 Change属性修改
//					 ？？？？？？？？？？？？？？？？？？？？？？？
//
//
//					 rm 可以删  删除普通文件
//					 rmdir 删除空目录
//					 rm - r 删除目录
//
//					 操作系统，数据结构，计算机网络，计算机组成原理。几门课很重要
//					 高等数学，离散数学，线性代数，概率论――
//					 四级一定要考
//
//					 su 进入root
//					 exit 由root返回普通用户
//					 rm - f 强制删除，普通用户可以直接删除root创建的目录
//					 rm - r 递归？？？？？？？？？？？？？？？
//					 rm - rf / 会删除根目录，千万别用（相当于删除c盘）
//					 如果是root创建的目录，普通用户删除时rm - r会有提示，rm - rf就不会，因为f有强制的意思
//
//					 man是手册，在linux中的作用相当于msdn在c中的，可以查函数
//					 man 3？？？？？？？？？？？？？
//					 man read 打开man
//					 q退出
//
//					 gedit 只能在图形化界面使用，王文件里些内容
//					 cat 显示文件内容
//					 cat - n把行号也打出来
//
//					 echo “hello”在显示器上显示
//					 echo “hello”>file 把hello写在file内
//>:重定向（把本应写在一个文件里的写在另一文件里）也可以新建文件。每次重定向，上次的内容都会被清空
//>> : 追加重定向
//cp 直接拷贝文件
//cp - r 拷贝目录
//cp - rf直接拷贝目录
//不能拷贝自身文件
//* 当前路径下的目录
//rm *删除当前目录下文件
//
//mv剪切；重命名
//
//more分屏显示 往下翻
//less上下翻都行
//
//head 从前往后读
//tail 从后往前读
//| 管道（将前置命令输出的数据传送到后置命令）
//管道文件p
//
//时间戳是从1970年1月1日到现在的时间
//
//
//date / cal / find(-name) / grep(-i - n - v) / wc(-l)
//grep的选项：
//[root@www ~]# grep[-acinv][--color = auto] '搜寻字符串' filename
//选项与参数：
//- a ：将 binary 文件以 text 文件的方式搜寻数据
//- c ：计算找到 '搜寻字符串' 的次数
//- i ：忽略大小写的不同，所以大小写视为相同
//- n ：顺便输出行号
//- v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
//--color = auto ：可以将找到的关键词部分加上颜色的显示喔！
//运算速度：cpu>内存>硬盘
//所有文件都在硬盘中
//所有文件都存在其目录下
//
//
//~显示当前用户的工作目录
//
//zip 打包压缩（方便传输，节省空间）
//用法（zip 文件名 lujing
//unzip 解压
//
//./*当前目录下的所有文件
//
// tar -czf 打包压缩（效率更高）
// （tar -czf  XXX.taz 路径)
// tar -xzf 解压解包
//
// uname -r操作系统版本和硬件结构
//
// halt也是关机
//
// 指令是程序也是文件
//
// shell（命令行解释器）（起用户和操作系统的沟通）
// 1.将用户的所有指令交给操作系统，再反馈给用户。传递结果
// 2.保护操作系统
// 3.执行命令分发给子进程
//
// bash是
// windows的shell是桌面
//
// 权限：
// 文件属性权限：是否可读，是否可写，是否可执行
// 人的分类：拥有者，所属组，other
//
// 是个字母，第一个是文件类型，后面9位分3类：拥有者u，所属组g，other(o)
// 可看成比特位(chmod 000 file)(chmod 766 file)
//
// chmod 改权限(chmod u-r file)(chmod u+rwx file)(chmod u-x,g+r,o-r file)
// (chmod  a+rwx file)――修改全部权限all
//
// 进入目录至少需要――可执行权限（一个面试题***）（目录默认拥有x）
// 在目录下创建文件――可写（删除目录下的文件也需要）
// 显示文件――可读权限
//
// rmdir可直接删除一个空目录，不可删除非空目录
// rm -rf * 可以删除当前目录下的所有文件（也可以写成 rm * -rf)
//
// 把ch声明为整形可以防止从输入读取的字符意外地被解释为EOF（这种情况可能会出现在整形提升时，如果未整形提升，那么应该读取前8个比特位，但是当整形提升时，就可能因为符号位被改变的缘故，发生一下子读取了32位的1，这个时候就会被意外解释为EOF）
//
// 第一个字母：文件属性
// p：管道文件
// c: 字符设备。键盘 打印机
// b: 块设备 。 硬盘设备
// k：
//
// //chgrp/chown/sudo chown/
// sudo:权限提升（不变为root，后边的命令却可以用root权限运行）（短期内的权限提升//su是长期的）
// root(超级管理员）具备最高权限，一个linux只有一个root  (root密码很重要哦*****）（一般不受权限约束）
//
// /home/dev 工作目录    改为root权限时用户目录可能也会变化
//
// 添加粘滞位后，other不能删除该目录下的文件（如果没有粘滞位，如果目录有w权限，other也可以删除该文件）
// 粘滞位给目录设****（只对目录有效）
//
//
// ping www.baidu.com 看是否联网（^c退出）
// yum list （）用来罗列当前主机中所能识别的所有软件包
// yum list | grep vim相当于搜索vim软件
// yum install vim直接自动安装vim软件****
// yum install vim -y  下载过程中默认询问消息都为yes
// yum remove vim删除文件
// yum命令在执行时加sudo权限（因为安装软件时需要向系统目录中写入内容）一般需要 sudo 或者切到 root 账户下才能完成.
//
// 如果安装命令不熟悉或是看不懂软件包名称的话，可以搜索centos 7 安装 （软件名）  在博客中查找安装命令
//
// （apt或apt-get也是软件安装器，但是再centos7下不适用，在Ubuntu、Linux Mint 和 elementary OS下可以
//
// rev的命令可以使输入的字符反转输出
// xeyes会出现一双眼睛
// oneko会出现一只小猫
// sl或者LS会出现一辆小火车
// cowsay (要说的话）
//
// 集成开发环境（vs ）集编写，编译，链接，调试，运行为一体的集成开发环境
// 而在linux当中，这些功能时分散的，vim负责代码的编写，是个编辑器
//
// vim是多模式编辑器，有命令，插入，末行（底行）,替换 模式模式(12种模式）
// 默认打开时命令模式
// R转到替换模式
// ESC转换到命令模式
// shift ：进入底行模式
// w写入（windows下的保存）
// w: 强制写入
// q退出
// wq保存并退出
// wq：保存并强制退出
//
// 命令模式进入插入模式的三种方式
// i转换到插入模式，光标不动
// a转换到插入模式，光标向后移动一位
// o转换到插入模式, 光标另起一行
//
// 由插入模式无法直接进入底行模式，任何模式之间的切换必须先转到命令模式再操作
//
// 在底行模式下 vs file.c 可以重新创建一个file.c的文件并分屏显示（光标在哪就编辑哪个文件）
// ctrl +ww 在分屏模式下切换光标
//
//
// 按ESC,再按u，会进入命令模式并清空屏幕
// 光标定位移动命令
// 写完代码后，按ESC，再输入shift+：  wq  回车退出
// gcc编译代码
// ./a.out运行代码
//
// set nu显示行号
// set nonu去掉行号
//
// 光标定位操作命令
// gg光标直接定位到第一行最左侧
// shift g或者G 光标定位到当前文本最后一行最左侧
// 4 + shift g定位到第四行最左侧
// shift $ 光标移到当前行的最右边
// shift ^                            最左边
// 左下上右hjkl（早期键盘时没有上下左右键的，比较方便）（按字符为单位移动的）
//
// b（左）,w（右）（按单词为单位移动的）
//
// yy  复制光标所在行
// p   是粘贴（从光标所在行的下一行粘贴）
// dd 删除（按行为单位）
// dd 和 p 组合使用，是剪切功能
// 100 dd 删除100行（很方便）
// 5 p 粘贴5行
// 3 yy 复制当前光标所在行及往下三行
//
// u 撤销
//
// shift + ~ 大小写快速转换（以字符为单位转换）
// x删除光标所在处后一个字符（5x可以删除光标所在处后5个字符）
// X删除光标所在处前一个字符
// r w 将光标后一个字符变为w（替换）
// 5rw 从光标向后三个字符变为w
//
//
// c语言要被翻译成汇编语言，计算机自己会自动将汇编语言变为二进制
// xshell――客户端，远程连接Linux
// 在联网情况下ifconfig
// 复制ip地址
// ssh远程帮助指令
// ssh hb@地址
// ping 地址 检查是否和自己linux联通
//
// 翻译分以下四个步骤：
// 预处理-E .i
// 编译-S .s
// 汇编-c .o
// 链接
//
// .iso镜像文件
// -o 后边接要生成的目标文件
// 以后都这么写gcc test.c -o mytest(也可以写成 gcc -o mytest test.c)
//
// 链接分 动态链接和静态链接
// 静态链接：
// 优点：节省时间；独立运行，不依赖第三方库
// 缺点：浪费内存，浪费空间
//
// 动态链接
// 优点: 加载时间快；节省空间
// 缺点：不能独立运行，依赖第三方库
//
// ldd 或者file（可执行程序）看是动态还是静态链接
// gcc默认链接方式：动态链接（要想变成静态链接，gcc时后边加static）
//
// 以.so结尾的是静态库
// 以.a                静态库
// libc/.so/.6说明链接的是c库
//
// 程序运行时要加载到内存中
//
// gcc生成的可执行程序默认是release版本
// gcc test.c mytest -g将release版本换为debug版本
// gdb b 18在18行代码加断电
// gdb n 朱果成
//
//
//
//
// libc.a
//
// make 是一条命令
// Makefile是一个文件，在源代码处创建;命名；里面放的是依赖关系和依赖方法
// ：左侧的是
// 一定要以Tab
//
// 。
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
